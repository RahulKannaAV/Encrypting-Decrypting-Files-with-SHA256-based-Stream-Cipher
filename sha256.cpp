#include <iostream>
#include <vector>
#include <cstring>
#include <cstdint>
#include<fstream>
#include<string>
using u8 = uint8_t;
using u32  = uint32_t;
using u64  = uint64_t;
using namespace std;

/* ================= SHA256 CONSTANTS ================= */

static const u32 K[64] = {
0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

/* ================= SHA256 HELPERS ================= */

inline u32 rotr(u32 x, u32 n){ return (x >> n) | (x << (32 - n)); }
inline u32 ch(u32 x, u32 y, u32 z){ return (x & y) ^ (~x & z); }
inline u32 maj(u32 x, u32 y, u32 z){ return (x & y) ^ (x & z) ^ (y & z); }
inline u32 ep0(u32 x){ return rotr(x,2) ^ rotr(x,13) ^ rotr(x,22); }
inline u32 ep1(u32 x){ return rotr(x,6) ^ rotr(x,11) ^ rotr(x,25); }
inline u32 sig0(u32 x){ return rotr(x,7) ^ rotr(x,18) ^ (x >> 3); }
inline u32 sig1(u32 x){ return rotr(x,17) ^ rotr(x,19) ^ (x >> 10); }

/* ================= SHA256 CORE ================= */

void sha256_transform(const u8 data[64], u32 state[8]) {
    u32 w[64];

    for(int i=0;i<16;i++)
        w[i] = (data[i*4]<<24)|(data[i*4+1]<<16)|
               (data[i*4+2]<<8)|(data[i*4+3]);

    for(int i=16;i<64;i++)
        w[i] = sig1(w[i-2]) + w[i-7] + sig0(w[i-15]) + w[i-16];

    u32 a=state[0], b=state[1], c=state[2], d=state[3];
    u32 e=state[4], f=state[5], g=state[6], h=state[7];

    for(int i=0;i<64;i++){
        u32 t1 = h + ep1(e) + ch(e,f,g) + K[i] + w[i];
        u32 t2 = ep0(a) + maj(a,b,c);
        h=g; g=f; f=e;
        e=d + t1;
        d=c; c=b; b=a;
        a=t1 + t2;
    }

    state[0]+=a; state[1]+=b; state[2]+=c; state[3]+=d;
    state[4]+=e; state[5]+=f; state[6]+=g; state[7]+=h;
}

vector<u8> sha256(const vector<u8>& input) {
    u32 state[8] = {
        0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,
        0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19
    };

    vector<u8> data = input;
    u64 bitlen = data.size() * 8;

    data.push_back(0x80);
    while((data.size() % 64) != 56)
        data.push_back(0x00);

    for(int i=7;i>=0;i--)
        data.push_back((bitlen>>(i*8))&0xff);

    for(size_t i=0;i<data.size(); i+=64)
        sha256_transform(&data[i], state);

    vector<u8> hash(32);
    for(int i=0;i<8;i++){
        hash[i*4]=(state[i]>>24)&0xff;
        hash[i*4+1]=(state[i]>>16)&0xff;
        hash[i*4+2]=(state[i]>>8)&0xff;
        hash[i*4+3]=state[i]&0xff;
    }
    return hash;
}

/* ================= STREAM CIPHER USING SHA256 ================= */

void sha256_stream_crypt(const vector<u8>& input,
                         vector<u8>& output,
                         const vector<u8>& key,
                         u64 nonce)
{
    size_t blocks = (input.size() + 31) / 32;
    output.resize(input.size());

    for(size_t i = 0; i < blocks; ++i) {   // <--- PARALLELIZE HERE

        vector<u8> seed = key;

        for(int j=7;j>=0;j--)
            seed.push_back((nonce>>(j*8))&0xff);

        for(int j=7;j>=0;j--)
            seed.push_back((i>>(j*8))&0xff);

        vector<u8> ks = sha256(seed);

        for(int j=0;j<32 && (i*32+j)<input.size();j++)
            output[i*32+j] = input[i*32+j] ^ ks[j];
    }
}

vector<u8> read_file(const string& filename) {
    ifstream file(filename, ios::binary);
    return vector<u8>((istreambuf_iterator<char>(file)),
                              istreambuf_iterator<char>());
}

void write_file(const string& filename, const vector<u8>& data) {
    ofstream file(filename, ios::binary);
    file.write(reinterpret_cast<const char*>(data.data()), data.size());
}


int main() {
    vector<u8> input = read_file("C prog.pdf");  
    vector<u8> encrypted, decrypted;

    vector<u8> key = {'H','P','C','_','K','E','Y'};
    u64 nonce = 12345;
 
    sha256_stream_crypt(input, encrypted, key, nonce);
    write_file("encrypted.bin", encrypted);

    sha256_stream_crypt(encrypted, decrypted, key, nonce);
    write_file("GProf_decrypted.pdf", decrypted);

    std::cout << "Done. Check decrypted\n";
}

